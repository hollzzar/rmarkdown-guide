[
["index.html", "R Markdown for Psychology Graduate Students Chapter 1 Welcome 1.1 Background 1.2 Getting started", " R Markdown for Psychology Graduate Students Holly Zaharchuk 2020-05-04 Chapter 1 Welcome I designed this guide to be a resource for psychology graduate students looking to streamline their research pipelines. With R Markdown, you can load, clean, manipulate, analyze, and present your data in one environment. This guide focuses on the presentation piece, with information on creating slides, posters, manuscripts, CVs, and reports in several formats, including HTML, PDF, and Microsoft Word. 1.1 Background This guide assumes a basic level of familiarity with R and RStudio. If you don’t know how to use either of these, there are several beginner tutorials you should check out first. I have also created primers for Beginner and Intermediate R in Chapter 9. 1.2 Getting started What is R Markdown? Markdown is a specific markup language with plain text-formatting syntax. R Markdown is a specific markdown variety. R Markdown and R are not the same thing! R Markdown combines R code (or code from other programming languages) and markdown in the RStudio integrated development environment (IDE). This allows you to embed code and text in the same document. You can install the R Markdown package from CRAN or GitHub: install.packages(&quot;rmarkdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/rmarkdown&quot;) 1.2.1 Tips Treat your data as read-only Comment code early and often Keep code chunks small Label chunks to help with diagnosing issues Nest all files under one directory (if possible) 1.2.2 General reference documents R Markdown Guide R Markdown Cheat Sheet R Markdown Reference Guide Keyboard shortcuts knitr documentation "],
["intro.html", "Chapter 2 Parts of a document 2.1 YAML header 2.2 Markdown 2.3 Code chunks", " Chapter 2 Parts of a document YAML header Markdown Code chunks 2.1 YAML header The first part of your document is called the YAML header. This is where you set the global options for the output and formatting. In the example below, I show the YAML header for a set of revealjs slides (see Chapter 4 for more on creating slides with this and other packages). I’ve included basic information, like the title and date, in addition to template-specific parameters, like whether there should be slide numbers or not. Section 6.2 has more information on setting YAML formatting parameters. 2.2 Markdown The plain text-formatting syntax of R Markdown allows for conversion to multiple document types. The image below shows an example of the basic syntax. # denotes a header, with ## denoting a subheader and so on, while numbers will function like you would expect a numbered list to behave in Word. However, unlike Word, the actual numbers don’t matter; I could’ve put all 1’s here, and R Markdown would’ve formatted them for me. Go to Chapter 5 for more information on markdown syntax. 2.3 Code chunks Code chunks are one of the core features of R Markdown. Code chunks are set apart from the markdown sections by three backticks at the beginning and end. In curly brackets, you must also specify the coding language you want to use (here, it’s R, with a lowercase r). You can add other arguments, like a name for the chunk (here, it’s “setup”), or other chunk options (like “echo = FALSE” to prevent the code from appearing in the document). You can find a full list of chunk options here. # This is a chunk of R code that adds an image knitr::include_graphics(&quot;images/example_chunk.png&quot;) There are multiple ways to run code chunks to test them in RStudio before creating your output. You can run code like you would in R by highlighting the relevant lines of code and hitting CTRL/command + enter. You can also hit the green “play” button in the upper right hand corner of the chunk to run that particular chunk. Each chunk is an island, so if you haven’t run a previous chunk that contains some variable you need in a later chunk, it’ll throw an error. At the top right of the open .Rmd document in RStudio, you’ll also see a Run dropdown menu. There, you can choose different options for running certain code chunks. Tip: you can use the chunk option “cache = TRUE” for very time-consuming chunks, but there are some catches as described here. "],
["output.html", "Chapter 3 Outputs 3.1 Output options 3.2 Rendering options 3.3 Knitting process", " Chapter 3 Outputs R Markdown can transform plain text and code into several different document formats. 3.1 Output options HTML is overall the most flexible. It supports the types of content we’re interested in creating as graduate students—tables, graphs, and the like—and you can easily transform your HTML output to a PDF with pagedown::chrome_print(file) if you have Google Chrome. The poster template I use follows this process. If you’re familiar with \\(\\LaTeX\\), you may be inclined to output directly to a PDF, since you can include inline \\(\\LaTeX\\) code in your documents (more on this in Chapter 6). The CV and manuscript templates that I use rely on the fine-grained typsetting capabilities of \\(\\LaTeX\\). To create a PDF, you need to have \\(\\LaTeX\\) installed locally. If you don’t already, you can install the lightweight tinytex distribution through the R console. install.packages(&quot;tinytex&quot;) You can also output to Microsoft Word and Powerpoint. I often work with colleagues who prefer to edit in Word, so sometimes I need to do this. I prefer not to if I can help it though, because you lose several important functions. For example, chunk options for aligning and setting the size of graphs and other images don’t work, and kable tables tend not to appear correctly. 3.2 Rendering options You can specify a particular output type in the YAML header with the output option. Then, you can press the Knit button or CTRL/command + shift + K to create or “knit” the document. Be sure to pay attention to indentation and colon placement in your YAML header, especially as you start to specify options for particular output types. As a rule of thumb, if you have anything more than output: output_type, you need to indent every new line, and have a colon at the end of the previous line. See Section 4.3 for an example of this. Instead of knitting, you can also render files in console with rmarkdown::render(file, output_format). This is essentially what Knit is doing. This approach allows you to create multiple output types quickly and easily. In my experience, I’m usually customizing my output very specifically for one output type by adding inline CSS or \\(\\LaTeX\\) code, so I really only use the render() function when I’m making parameterized reports. 3.3 Knitting process When you Knit or render your document, there’s a particular sequence of events that happens under the hood. Your R Markdown document is piped through to pandoc by the knitr package, which runs your code chunks and knits them together with the plain text you’ve included. Pandoc ultimately handles the conversion to a particular output format. Understanding this process can help you troubleshoot when you run into issues. You can find more on troubleshooting in Chapter 8. Knitting process from Writing Your Thesis with R Markdown "],
["template.html", "Chapter 4 Templates 4.1 Built-in templates 4.2 Templates from R packages 4.3 User-defined templates", " Chapter 4 Templates Built-in templates Templates from R packages User-defined templates 4.1 Built-in templates R Markdown has several output templates built in, and you just have to specify them in the YAML output. These include: Presentations ioslides and Slidy for HTML Beamer for PDF Interactive Shiny documents and presentations 4.2 Templates from R packages You can also download specific templates from CRAN and GitHub. A few that I’ve used or played with include: Presentations: revealjs CVs: vitae Academic posters: posterdown APA articles: papaja Journal templates: rticles HTML theme: prettydoc 4.3 User-defined templates There are also ways to include templates for particular outputs in the YAML header. 4.3.1 PDF For PDFs, you can include \\(\\LaTeX\\) templates, but you need to pay attention to the use of $. The PLOS template shown in the image below failed to compile when I first downloaded it, because $ are special characters for pandoc. After I added a second $ throughout the document (you just use find and replace for this), it worked. See Section 6.3.1 for calling specific \\(\\LaTeX\\) packages in R Markdown. 4.3.2 Word You can also set up Word document templates. To do this, you need to use the Styles Pane in the Word Document you want to use as a template. Highlight the text you want to format, make the desired changes, then find the style that applies to that section, and find “Update to Match Selection” in the dropdown menu. In the example below, you can see that I’m editing the “Title” format, so I need to update that particular entry in the Styles Pane. You have to do this for every text element in the document, but once you’ve set it up once this way, you can simply include it the same way as the \\(\\LaTeX\\) template shown above. "],
["content.html", "Chapter 5 Content 5.1 Markdown overview 5.2 Special characters 5.3 Inline R", " Chapter 5 Content 5.1 Markdown overview R Markdown: The Definitive Guide and this R Markdown cheatsheet provide information on the typesetting capabilities of R Markdown. In general, R Markdown typesetting options include *italics*, **bold**, and ~~strike-through~~. These are achieved by wrapping text in a certain number of asterisks or tildes. There are also (parentheses), [square brackets], and \"quotation marks\" that can have special functions in markdown, like creating hyperlinks: [text](link). With many of these typesetting characters, if you highlight the text you want to format (by clicking and dragging your cursor), you can just hit the character once to wrap the text automatically. This way, you don’t have to go to the beginning and end of the text and place the characters individually. Another note about R Markdown is that line spacing matters. For example, if I wanted to include bullet points after this sentence, they wouldn’t render properly if I didn’t hit enter twice before starting them. In other words, I need to have a full line of white space before bullet points and numbered lists. If you’re having issues with your document rendering correctly, make sure you have line breaks between lists, paragraphs, and headers. 5.2 Special characters If you want any special characters in R Markdown, \\(\\LaTeX\\), or pandoc to appear as text, rather than having them perform some function, you need to “escape” them with a backslash. For example, pound signs/hashtags, backslashes, and dollar signs need to be preceded by a backslash. This also applies to any chunk outputs that contain strings, as with knitr::kable tables with \\(\\LaTeX\\) functions or characters (e.g., Greek letters like \\(\\eta\\) to report partial eta-squared or functions like \\textit{p} to italicize the text). Sometimes you even need multiple backslashes, so you may have to play around to troubleshoot if they’re not rendering correctly. Speaking of \\(\\LaTeX\\), you can engage “math-mode” by putting dollar signs around \\(\\LaTeX\\) math commands. This way, you can include equations, International Phonetic Alphabet (IPA) symbols, and the like in R Markdown (even if you’re not outputting to a PDF). For example, I can write \\(e = mc^2\\) in a sentence like this just by wrapping the equation in a single set of dollar signs, or I can use two sets to center the equation: \\[e = mc^2\\] 5.3 Inline R A very useful aspect of R Markdown is that you can call R objects and functions in markdown or the YAML header by sandwiching them between backticks. For example, let’s say I want to report on the names of the flower species in the iris dataset. # Pull species column from iris and get unique values in column species &lt;- iris %&gt;% pull(Species) %&gt;% unique() # Print species variable print(species) ## [1] setosa versicolor virginica ## Levels: setosa versicolor virginica Maybe I also want to save a variable with the number of species in this list. # Get number of unique species species_count &lt;- length(species) # Print number of species print(species_count) ## [1] 3 I can call species and species_count in the markdown text to reference these variables dynamically. Just as in a code chunk, I have to specify that I’m working with R code by including a lower-case r in the backticks with the variable. So if I put “r species_count” between backticks, I can report that there are 3 species without typing out the number itself. Or I can reference the variable with the exact species names: setosa, versicolor, virginica. You can see what the markdown looks like in the screenshot below. "],
["format.html", "Chapter 6 Formatting 6.1 YAML parameters 6.2 YAML references 6.3 Inline code 6.4 Custom functions 6.5 Editing templates", " Chapter 6 Formatting 6.1 YAML parameters There are several general YAML options that you can include in the YAML header to format your documents. You can also add params to the YAML header that you can specify when you render your document and call in your code chunks to make parameterized reports. Some YAML options require quotation marks, while others don’t. In general, if the YAML option is a string of text that you’re specifying, like the title or your name, then it should be in quotes. If you’re setting a programmatic option, like the output type, then it shouldn’t be in quotes. For the string options, there’s some custom formatting you can do. The first example below shows how you can center a title and force a line break. The second shows how you can automatically pull the date and time when you knit your document and format it in a particular way. This is actually R code that is embedded in a string by putting the function call between backticks with a lowercase r. You can use the same principle to put R code and functions in the text of an R Markdown document (see Section 5.3 for more information). # Show date formatting code # You can run ?Sys.time in the console for more information # on the options you can pass to format format(Sys.time(), &#39;%B %d, %Y&#39;) ## [1] &quot;May 04, 2020&quot; There are also template-specific parameters, but you’ll need to look at the specific package documentation to know what these are. 6.2 YAML references In your YAML header, you can reference other documents for formatting and content. 6.2.1 .bib To cite references, you need to set the bibliography option in the YAML header. I use BibDesk for my reference manager, which creates a .bib file, or you can create a .bib file directly in \\(\\LaTeX\\). You can also construct a .bib file through R. See Section 9.1.5 or the .Rmd file for my CV for examples with the scholar package. By default, if you reference a .bib file, the references will appear at the very end of the document. This is usually fine, but sometimes you may want to control the placement of the references, as with a CV. In this case, you can use a .lua filter as described in Section 6.2.4 to place your references in a particular spot. To create in-text citations, you’ll use the cite key from your .bib file with the @ symbol. Full information on citing syntax can be found here. When you cite something from your .bib file, it will appear in your references section when you knit your document. If you want to include all of the references from your .bib file in your reference section, regardless of whether you’ve cited them or not in the document, set the nocite option in the YAML header to “@*”. 6.2.2 .csl To determine the type of formatting for your references, you can include a citation style language or .csl file. There are other ways to set the format of bibliographies, but a .csl file allows fine-grained control over citations that you can also customize. My CV repository has a customized APA 6 .csl file for arranging references in descending order by date. My Psychonomics poster repository also has a customized APA 6 .csl to fix some small bugs. 6.2.3 .cls and .css You can include .cls files (not to be confused with the .csl files above) for \\(\\LaTeX\\) styling or .css files for HTML styling. You can see an example of the .cls file that formats my CV in Section 6.5.1. This guide itself uses .css files that you can find here to control the formatting. 6.2.4 .lua Sometimes, you need to interact with pandoc directly in order to achieve a particular formatting outcome. To do this, you need to use a .lua filter. The multiple-bibliographies.lua file is incredibly useful. It allows you to use multiple bibliographies in one document, as I do in my CV (one for publications, another for conference presentations). Even if you don’t have multiple bibliographies, using this .lua filter will allow you to place your reference section in a particular part of your document. The .Rmd file for my CV shows how to use multiple bibliographies in R Markdown. First, you need to add a name to each bibliography in the YAML header with an underscore. You can also see how I’ve referenced this .lua file in the pandoc_args option in the YAML header. For this document to knit properly, the .lua file needs to be in the same place as my .Rmd file. Then, you can place the reference section for each bibliography in the appropriate place. This example also shows how you can alter the formatting locally for just the reference section with \\(\\LaTeX\\) commands. Another very useful .lua file handles in-text APA citations. By default, pandoc uses “&amp;” for in-text citations where APA would require “and,” even if you’re using a .csl file for APA formatting. Rather than downloading a file like with multiple-bibliographies.lua, this file is already stored with pandoc: you just need to reference it. Follow these instructions to access and reference this .lua filter The example below from my Master’s thesis shows how you can reference multiple .lua filter in one document. 6.3 Inline code R Markdown supports inline code for custom formatting. 6.3.1 \\(\\LaTeX\\) In PDFs, you can use code, typesetting commands (e.g., \\vspace{12pt}), and specific packages from \\(\\LaTeX\\). There are useful lists of symbols here and here. Check out Writing Your Thesis with R Markdown and Section 6.3.1 below for examples using \\(\\LaTeX\\) packages and typesetting commands. I’ve included examples of calling packages in the YAML header and using inline functions from my statistics homework below (also see Writing Your Thesis with R Markdown). 6.3.2 CSS/HTML In HTML documents, you can include CSS commands. I have some examples in these revealjs slides, where I wanted to left-align slide text while keeping titles centered. Here are some examples of using CSS from my Psychonomics poster. The first example includes custom CSS in a knitr::kable table to add borders of a particular color between some rows. The second example changes the font size of the references section at the end of the poster. 6.4 Custom functions If you’re fairly comfortable with R, you can write formatting functions for yourself to make your life easier when you’re referencing variables in your text. When I was working on my Master’s thesis, I wrote some custom functions for statistical values that I had to report over and over. This was particularly useful when I had to switch from referring to any p values over .05 as p &gt; .05 to p = the exact value. I just had to change the one function by commenting out a couple lines and re-knit my document. The function is included below; this was the most complicated of the ones I wrote, which included degrees of freedom, t and F values, reaction times, and percentages. # Make number formatting function for p values # val is the p value I want to format # format_code specifies whether I want to include the symbol or not # format_code defaults to including the symbol p_formatting &lt;- function(val, format_code = 1) { # If I want to include the symbol (when I&#39;m calling this variable in text) if (format_code == 1) { # If the p value is less than .001, get the less than symbol # Otherwise, get the equals symbol # The next line, which I commented out for my thesis, # looks to see if the value was greater than .05 sign_type &lt;- if_else(val &lt; 0.001, &quot;&lt;&quot;, &quot;=&quot;) sign_type &lt;- if_else(val &gt; 0.05, &quot;&gt;&quot;, sign_type) # If the p value is less than .001, set the value equal to .001 if (sign_type == &quot;&lt;&quot;) { val &lt;- &quot;.001&quot; # If the p value is greater than .05, set the value equal to .05 # I commented out these next two lines for my thesis } else if (sign_type == &quot;&gt;&quot;) { val &lt;- &quot;.05&quot; # Otherwise, get the actual p value, # round it to three decimal places, and # remove the leading zero } else { val &lt;- sprintf(&quot;%.3f&quot;, val) val &lt;- substring(val, 2) } # Combine the new/formatted p value with &gt;, &lt;, or =, # depending on the p value val_string &lt;- paste(sign_type, val, sep = &quot; &quot;) val_string # If I don&#39;t want the symbol (as in a table), # just round the value to three decimal places # and remove the leading zero } else if (format_code == 0) { val &lt;- sprintf(&quot;%.3f&quot;, val) val_string &lt;- substring(val, 2) val_string } } I’ve included an example with this function below to demonstrate how you can really streamline your analysis-to-presentation pipeline with a simple function. # Create arbitrary p value p_value &lt;- 0.0123 # Format p value including symbol p_value_1 &lt;- p_formatting(p_value) # Format p value not including symbol p_value_0 &lt;- p_formatting(p_value, format_code = 0) Here is the original p value: 0.0123. I can write p = .012 to reference the variable that already has the symbol, or I can reference the variable without the symbol: .012. I’ve included an image of these lines below to give you a sense of how this looks in markdown. 6.5 Editing templates To make extremely custom edits to templates, sometimes you have to edit the template documents directly. If the template generates a style document (e.g., .cls) in the directory with your .Rmd file, you can usually edit that without going to the package. Otherwise, you have to find out where your computer stores your R packages and edit the template there. 6.5.1 Directory documents Some templates output formatting documents in your working directory. These are easier to access and edit. For example, knitting the vitae::awesomecv template created a .cls file that I could edit to change font sizes/colors. 6.5.2 Package documents To find out where your packages “live,” you can call installed.packages(). When you leave the parentheses blank (i.e., if you don’t provide any arguments), as I’ve done below, the function will return all of the packages you have installed. I’ve stored them as a dataframe, and then filtered for an example. Here, I’m looking at the posterdown package. # Make dataframe with installed packages pkgs &lt;- installed.packages() %&gt;% as.data.frame() # Pull posterdown package pstr &lt;- pkgs %&gt;% select(Package, LibPath, Version, Depends, Imports) %&gt;% dplyr::filter(Package == &quot;posterdown&quot;) # Make table kable(pstr) %&gt;% kable_styling(bootstrap_options = &quot;condensed&quot;, full_width = FALSE, font_size = 12) Package LibPath Version Depends Imports posterdown /Library/Frameworks/R.framework/Versions/3.5/Resources/library 1.0 NA pagedown, rmarkdown, yaml To edit package documents once you’ve located them, you should proceed with caution. Be sure to: Save the original template and move it to a different location (in the example below, I made the “original” folder and put the original template there) Make one change at a time, and then re-knit the document to see what changed Name the updated template with the same name in the same place as the original (here, in the “resources” folder) "],
["organization.html", "Chapter 7 Organization 7.1 Child documents 7.2 Sourcing code", " Chapter 7 Organization If you’re working on a large R Markdown project, like a thesis, it’s inevitable that you will have several code chunks to perform pieces of one process (e.g., reformatting data for plotting and then creating the plots), and you will have lots of chapters/sections of markdown. At a minimum, you want to keep your chunks small and name them for easy troubleshooting and use headers at multiple levels. One thing to note is that you cannot have the same chunk names anywhere in your document or sub-documents; this will throw an error. If you go to the bottom left-hand corner of your .Rmd file in RStudio, you’ll see a small drop-down menu. There, you can jump to specific headers and code chunks. As your documents grow, however, even these sections will become difficult to keep straight. This is when you want to use what are called child documents. This just means that you have separate R Markdown documents that you reference in your main R Markdown document. These are also great if you need to include the same code or text in multiple documents. 7.1 Child documents The screenshot below shows some code from my main Master’s thesis R Markdown document. In this example, I referenced another R Markdown document called Load, as well as one called chapter1. All you have to do is make a code chunk in which you set the “child” parameter equal to the file that you want to reference (and file path if it’s in a subfolder, as I have here). The chunk itself must be empty. The Load document contained several code chunks for loading and processing my data and analyses for presentation. I’ve included a screenshot of the top of this document below. You can see that I just gave it a pagetitle in the YAML header, and then included the code chunks that I wanted. This helped keep the main document uncluttered. One thing to note is that when you’re running your code chunks to work on your document, if you just run the code chunk referencing the child document, nothing will happen. You have to open that R Markdown document and run it to evaluate those chunks. You also saw that I loaded the chapter1 child document. This allowed me to separate out each of the sections of my thesis into different documents, in addition to separating out the analyses as with the Load document. I organized these documents into subfolders to keep everything clean. I’ve included a screenshot of the organizational structure below. At the top level, I had the main R Markdown document and necessary reference documents (see Section 6.2 for more information on including reference documents in the YAML header). In the first subfolder, I had the documents for each section of the thesis (e.g., chapter1 is the introduction). In the lower subfolder, I had documents that only contained code chunks (e.g., running statistical analyses and formatting the values for referencing). 7.2 Sourcing code I also use a similar decentralized organizational structure for my actual R processing scripts. You can use source(file) to source all of the code from one script into another, similarly to using child documents in R Markdown. The Load document above actually sources R scripts in the code chunks to load those data into the thesis document. I’ve included a screenshot of the folder with all of my R scripts for preparing my thesis data. The data themselves are in the behavioral and erp subfolders. The DM_global_vars file contains variables, like the custom formatting functions I described in Section 6.4, that I used across the scripts. I recommend having such a file that you source at the lowest level of the sourcing/child document hierarchy. That way, if you need to change something, you can make that change in just one place. "],
["trouble.html", "Chapter 8 Troubleshooting 8.1 Warnings vs. errors 8.2 RStudio vs. R Markdown environments 8.3 Package issues 8.4 Strategies", " Chapter 8 Troubleshooting Warnings vs. errors RStudio vs. R Markdown environments Package issues Strategies for troubleshooting issues 8.1 Warnings vs. errors 8.1.1 Warnings Warnings won’t stop your document from compiling, but generally indicate that you should change something in your code. 8.1.2 Errors There are different kinds of errors that you can encounter. In general, you can distinguish chunk errors from R Markdown errors by their appearance. Errors will usually tell you which line of the document they’re in, but they can be misleading or inaccurate, so try to understand the error message first before going to look for the source. As always, Google and Stack Overflow are your friends! Chunk error: R Markdown error: 8.2 RStudio vs. R Markdown environments Running a chunk executes the code in the console and adds the output to your R environment; however, your R environment is separate from the environment created when knitting a document. If you’re getting an error message that says a particular variable or package doesn’t exist when it’s loaded in your R environment, it’s usually because you haven’t included it in a previous chunk. # Define new variable y y &lt;- 100 # When I run this chunk, I get the expected output (150), # but it fails when I try to knit the document # I&#39;ve set eval=FALSE for this chunk, so it doesn&#39;t try to run and prevent my document from knitting print(x + y) 8.3 Package issues 8.3.1 Package specification If a function you want to use isn’t included in base R, you need to load the package that it’s in. The most basic way to do this is to run library(package) for each individual package. As you saw in my “setup” chunk example in Section 2.3, my preferred way is to set a list of packages and then load them with the p_load function from the pacman package. This way, you can easily load multiple packages at once. If you don’t want to load a whole package, you can use this notation: package::function. This tells R which package to look in. You especially want to do this if there are what are called “namespace conflicts,” where multiple packages have the same function name. I often run into this issue with the filter function from dplyr, so I always specify dplyr::filter even if I’ve already loaded dplyr. 8.3.2 Updates You may get warnings or errors related to packages being out of date or certain functions being “deprecated.” You may need to update packages and software that interact with R and R Markdown to get your code to run and documents to knit. Depending on the feature that is out of date, there are different strategies for updating. Update your TeX distribution from the command line Update all packages (including rmarkdown) in library with update.packages(path) Update individual packages by reinstalling with install.packages(package) Update R in the console with updateR package Redownload RStudio to update 8.4 Strategies If you’re running into any issues with your code or knitting your document, here are some things you can try: Reset your R environment Clear all variables by running rm(ls = list()) in the console Restart your R environment with CTRL/(control + fn) + shift + F10 Run all chunks individually in order before compiling to test code Search for information Use Help window Search for package in console with ?package or ??package Google the package and error you’re getting "],
["supplement.html", "Chapter 9 Supplementary materials 9.1 Beginner R 9.2 Intermediate R 9.3 Practice materials", " Chapter 9 Supplementary materials 9.1 Beginner R Basic R functionality Reading in data Tidy R philosophy Manipulating data with core tidyr functions 9.1.1 Basic R functionality Variables Functions Operators 9.1.2 Variables The way R stores your information will determine the kinds of functions/operators you can use Data: dataframes Values: lists, vectors, matrices, etc. # Variables can be numbers, strings, etc. some_val &lt;- 200 other_val &lt;- TRUE # Variables can also be lists of numbers, strings, etc. a_list &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # We can also make dataframes (which are essentially special lists) a_dataframe &lt;- tibble(column_1 = 1:3, column_2 = a_list) 9.1.3 Functions Functions take a certain number and certain types of “arguments” base R functions: part of downloading R Packages: need to be installed, then loaded install.packages(package) once (or to update package) library(package) every R session Use Help window or ?package to check argument names, types, and defaults Named arguments without values are required (and user-defined) Named arguments with values show defaults Elipses mean that you can add other optional arguments # file: required # header = TRUE: default # ...: other potential arguments, like stringsAsFactors = FALSE read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) 9.1.4 base R # base R function # Count the number of rows in this dataframe nrow(a_dataframe) ## [1] 3 # If I give nrow() too many arguments, it will throw an error nrow(a_dataframe, a_list) # If I give it the wrong kind of argument, it will just return NULL # Some functions won&#39;t run at all with wrong kind of argument nrow(a_list) ## NULL 9.1.5 Packages # scholar package library(scholar) # get_publications function # Pull publications from Google Scholar for Marie Curie get_publications(&quot;EmD_lTEAAAAJ&amp;EmD_lTEAAAAJ&amp;&quot;) %&gt;% dplyr::filter(cites &gt; 30) %&gt;% distinct(title, .keep_all = TRUE) %&gt;% select(author, title) %&gt;% head(2) %&gt;% kable() author title P Curie, M Sklodowska-Curie Sur une substance nouvelle radio-active, contenue dans la pechblende E Curie Madame Curie: a biography 9.1.6 Operators Relational: &gt;, &lt;, ==, !=, &lt;=, &gt;= is.na(), exists(), etc. will return TRUE/FALSE values grep(), filter(), str_detect(), etc. use TRUE/FALSE values Logical: !, &amp;, &amp;&amp;, |, || Arithmetic 9.1.7 Reading in data General parameters for csv files read.csv(&quot;file_name.csv&quot;, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = &quot;&quot;) Avoid special characters (including spaces) in file names, directories, and column headers! readxl package for Excel spreadsheets APIs for direct access to online data qualtRics package for Qualtrics data ggmap package for Google services (geolocation data) read_table() from readr package for text files 9.1.8 Tidy R philosophy One variable per column One observation per row 9.1.9 Manipulating data with tidyr %&gt;%: pass the results of one function on to another select(): choose columns by name mutate(): add/change columns filter(): filter for (or out) rows group_by() and summarise(): perform operations on groups of data gather() and spread() pivot_longer() and pivot_wider(): condense multiple columns into one or the inverse separate() and unite(): split a column into multiple or the inverse 9.1.10 Other helpful tidyr functions slice(): choose a row pull(): choose a column Helper functions for select() (e.g., contains()) join family of functions: combine datasets based on a shared unique identifier union(): combine datasets by rows (column names must be the same) replace_na()/drop_na(): alter/remove rows with NA values 9.1.11 Helpful base R functions rbind() and cbind(): add rows/columns nrow() and ncol(): count rows/columns unique(): pull unique values Indexing with var$column and var[row, column] which() with column/row indexing 9.1.12 Other packages and functions tibble package for dataframes with tibble() kableExtra() for kable() tables ggplot2 package for graphs (cheat sheet here) factor() for ordering text labels in graphs Use na.rm = TRUE argument (e.g., in mean()) to remove NA values from calculations 9.2 Intermediate R Dealing with free-response text Dynamic variable creation and reference Helpful functions Other tips 9.2.1 Free-response text Regular expressions (cheat sheet here) Pattern matching Return position/value of elements that match a pattern: grep(), agrep() Return TRUE/FALSE: grepl(), agrepl(), str_detect() Change a pattern: sub(), gsub(), replace() Return position of pattern for all elements: regexpr(), gregexpr(), regexec() Use perl = TRUE argument to handle especially complex patterns # List of elements fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) # grep position grep(pattern = &quot;le&quot;, x = fruit) ## [1] 1 4 # grep value grep(pattern = &quot;le&quot;, x = fruit, value = TRUE) ## [1] &quot;apple&quot; &quot;pinapple&quot; # agrep (can also specify value = TRUE) agrep(pattern = &quot;le&quot;, x = fruit, max.distance = 0.1) ## [1] 1 3 4 # regexpr # match.length attribute gives starting position of match # index.type attribute gives length of matched text regexpr(pattern = &quot;le&quot;, text = fruit) ## [1] 4 -1 -1 7 ## attr(,&quot;match.length&quot;) ## [1] 2 -1 -1 2 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE 9.2.2 Dynamic variables # Variables vals &lt;- rep(1:3, 3) name &lt;- &quot;assign_example&quot; # Assign values to variable name assign(name, vals) # Use the variable as usual assign_example ## [1] 1 2 3 1 2 3 1 2 3 # You can also get the new variable from the name get(name) ## [1] 1 2 3 1 2 3 1 2 3 # You can add to this variable dynamically as well assign(name, c(get(name), 4:6)) # New output assign_example ## [1] 1 2 3 1 2 3 1 2 3 4 5 6 9.2.3 Helpful functions apply(), lapply(), sapply(), tapply() source() variables from R scripts %notin% and %in% (compared to != and ==) # Example using apply(): go across columns of dataset # and substitute characters language &lt;- apply(language, 2, function(x) gsub(&quot;\\\\\\\\&quot;, &quot;&quot;, x, fixed = TRUE)) # Source other sripts source(&quot;data_cleaning.R&quot;, local = TRUE) # Helper function &quot;%notin%&quot; &lt;- Negate(&quot;%in%&quot;) # Example from processing pipeline for Qualtrics data unusable &lt;- c(&quot;0&quot;,&quot;00&quot;,&quot;107&quot;) dat %&gt;% dplyr::filter(Progress==100 &amp; ID %notin% unusable) 9.2.4 Other tips Store ggplot2 parameters in a list() list() vs. c() 9.3 Practice materials You can find practice materials for R Markdown and R here. You’ll want to clone this repository or download the following documents/folders: brownbag_activity.Rmd data_cleaning.R apa.csl /data "]
]
